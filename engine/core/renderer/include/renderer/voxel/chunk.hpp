#pragma once

#include "voxel_types.hpp"
#include <array>
#include <vector>
#include <memory>
#include <atomic>

namespace PyNovaGE {
namespace Renderer {
namespace Voxel {

// Forward declarations
class VoxelMesh;

/**
 * @brief A chunk represents a 16x16x16 block of voxels
 * 
 * Chunks are the fundamental unit of the voxel world. They manage their own
 * voxel data, meshing, and rendering state. Each chunk covers a 16x16x16 area
 * from bedrock to sky limit.
 */
class Chunk {
public:
    // Chunk state for loading/generation
    enum class State {
        Empty = 0,        // No data generated
        Generating,       // Being generated by world gen
        Generated,        // Data generated, needs meshing
        Meshing,          // Being meshed on background thread
        Ready,            // Ready for rendering
        Unloading         // Being unloaded
    };

    /**
     * @brief Default constructor
     */
    Chunk();
    
    /**
     * @brief Construct a chunk at given coordinates
     * @param coord Chunk coordinates in world space
     */
    explicit Chunk(const ChunkCoord2D& coord);
    
    /**
     * @brief Destructor - cleans up mesh data
     */
    ~Chunk();

    // Non-copyable but movable
    Chunk(const Chunk&) = delete;
    Chunk& operator=(const Chunk&) = delete;
    Chunk(Chunk&&) = default;
    Chunk& operator=(Chunk&&) = default;

    /**
     * @brief Get voxel at local coordinates
     * @param x Local x coordinate (0-15)
     * @param y Local y coordinate (0-15) 
     * @param z Local z coordinate (0-15)
     * @return VoxelType
     */
    VoxelType GetVoxel(int x, int y, int z) const;
    VoxelType GetVoxel(const ChunkCoord& pos) const { return GetVoxel(pos.x, pos.y, pos.z); }
    
    /**
     * @brief Set voxel at local coordinates
     */
    void SetVoxel(int x, int y, int z, VoxelType voxel_type);
    void SetVoxel(const ChunkCoord& pos, VoxelType voxel_type) { SetVoxel(pos.x, pos.y, pos.z, voxel_type); }


    /**
     * @brief Get chunk coordinates
     */
    const ChunkCoord2D& GetCoordinates() const { return coordinates_; }
    
    /**
     * @brief Get world position of chunk (bottom-left corner)
     */
    Vector3f GetWorldPosition() const {
        return Vector3f(static_cast<float>(coordinates_.x * CHUNK_SIZE), 0.0f, static_cast<float>(coordinates_.z * CHUNK_SIZE));
    }

    /**
     * @brief Get current chunk state
     */
    State GetState() const { return state_.load(); }
    
    /**
     * @brief Set chunk state
     */
    void SetState(State state) { state_.store(state); }

    /**
     * @brief Check if chunk is ready for rendering
     */
    bool IsReady() const { return state_.load() == State::Ready; }
    
    /**
     * @brief Check if chunk has been modified and needs remeshing
     */
    bool IsDirty() const { return dirty_.load(); }
    
    /**
     * @brief Mark chunk as dirty (needs remeshing)
     */
    void MarkDirty() { dirty_.store(true); }
    
    /**
     * @brief Clear dirty flag
     */
    void ClearDirty() { dirty_.store(false); }

    /**
     * @brief Check if chunk is empty (all air)
     */
    bool IsEmpty() const { return empty_.load(); }

    /**
     * @brief Generate simple test chunk data
     * Creates a basic landscape for testing
     */
    void GenerateTestData();
    
    /**
     * @brief Clear all voxel data (set to air)
     */
    void Clear();

    /**
     * @brief Get the mesh for this chunk
     */
    VoxelMesh* GetMesh() const { return mesh_.get(); }
    
    /**
     * @brief Set the mesh for this chunk (takes ownership)
     */
    void SetMesh(std::unique_ptr<VoxelMesh> mesh);

    /**
     * @brief Get voxel count statistics
     */
    struct VoxelStats {
        size_t solid_voxels = 0;
        size_t air_voxels = 0;
        size_t total_voxels = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;
    };
    
    VoxelStats GetStats() const;

    /**
     * @brief Check if coordinates are valid within chunk
     */
    static bool IsValidCoordinate(int x, int y, int z) {
        return x >= 0 && x < CHUNK_SIZE && 
               y >= 0 && y < CHUNK_SIZE && 
               z >= 0 && z < CHUNK_SIZE;
    }

private:
    // Convert 3D coordinates to 1D index
    static constexpr size_t GetIndex(int x, int y, int z) {
        return static_cast<size_t>(y * CHUNK_SIZE * CHUNK_SIZE + z * CHUNK_SIZE + x);
    }
    
    // Update empty status by checking all voxels
    void UpdateEmptyStatus();

private:
    ChunkCoord2D coordinates_;                              // Chunk position in world
    std::array<VoxelType, CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE> voxels_; // Voxel data
    std::unique_ptr<VoxelMesh> mesh_;                     // Rendered mesh
    
    std::atomic<State> state_{State::Empty};             // Current chunk state  
    std::atomic<bool> dirty_{false};                     // Needs remeshing
    std::atomic<bool> empty_{true};                      // All voxels are air
};

/**
 * @brief Voxel mesh data for rendering
 * Contains vertex and index buffers for a chunk
 */
class VoxelMesh {
public:
    VoxelMesh() = default;
    ~VoxelMesh();
    
    // Non-copyable but movable
    VoxelMesh(const VoxelMesh&) = delete;
    VoxelMesh& operator=(const VoxelMesh&) = delete;
    VoxelMesh(VoxelMesh&&) noexcept;
    VoxelMesh& operator=(VoxelMesh&&) noexcept;

    /**
     * @brief Upload vertex and index data to GPU
     */
    void UploadData(const std::vector<VoxelVertex>& vertices, const std::vector<uint32_t>& indices);
    
    /**
     * @brief Bind the mesh for rendering
     */
    void Bind() const;
    
    /**
     * @brief Unbind the mesh
     */
    void Unbind() const;
    
    /**
     * @brief Draw the mesh
     */
    void Draw() const;
    
    /**
     * @brief Get vertex count
     */
    size_t GetVertexCount() const { return vertex_count_; }
    
    /**
     * @brief Get index count
     */
    size_t GetIndexCount() const { return index_count_; }
    
    /**
     * @brief Check if mesh has data
     */
    bool HasData() const { return vertex_count_ > 0; }
    
    /**
     * @brief Get triangle count
     */
    size_t GetTriangleCount() const { return index_count_ / 3; }

private:
    uint32_t vao_ = 0;        // Vertex Array Object
    uint32_t vbo_ = 0;        // Vertex Buffer Object
    uint32_t ebo_ = 0;        // Element Buffer Object
    size_t vertex_count_ = 0; // Number of vertices
    size_t index_count_ = 0;  // Number of indices
};

} // namespace Voxel
} // namespace Renderer
} // namespace PyNovaGE
